# Story 1.2: Set Up Docker and Deployment Configuration

## Status
Draft

## Story

**As a** developer,  
**I want** Docker containerization for both frontend and backend with a Makefile for easy development workflow,  
**so that** I can deploy the application consistently across environments and develop with containerized services.

## Acceptance Criteria

1. Dockerfile is created for FastAPI backend with Python 3.14
2. Dockerfile is created for Next.js frontend (or multi-stage build)
3. docker-compose.yml is created for local development (backend, frontend, PostgreSQL)
4. Makefile is created with standard development commands (build, up, down, logs, clean, etc.)
5. Makefile supports volume mounting for development mode (hot-reload for both frontend and backend)
6. Docker images use intuitive names (e.g., `librilabs-translator-backend`, `librilabs-translator-frontend`)
7. Environment variables are properly configured via .env files
8. Docker containers can be built and run locally using Makefile commands
9. Application runs successfully in Docker containers
10. Backend health check endpoint works from containerized backend
11. Frontend can communicate with backend API from containers
12. Development workflow is documented (using Makefile commands)

## Tasks / Subtasks

- [ ] Task 1: Create Backend Dockerfile (AC: 1)
  - [ ] Create `backend/Dockerfile` with Python 3.14 base image
  - [ ] Install system dependencies if needed
  - [ ] Copy requirements.txt and install Python dependencies
  - [ ] Copy application code
  - [ ] Set working directory
  - [ ] Expose port 8000
  - [ ] Set default command to run uvicorn
  - [ ] Use multi-stage build if appropriate for optimization
  - [ ] Ensure .dockerignore is configured to exclude unnecessary files

- [ ] Task 2: Create Frontend Dockerfile (AC: 2)
  - [ ] Create `frontend/Dockerfile` with Node.js base image (appropriate version for Next.js 16.0.4)
  - [ ] Install dependencies
  - [ ] Copy application code
  - [ ] Set working directory
  - [ ] Expose port 3000
  - [ ] Set default command for development mode
  - [ ] Consider multi-stage build for production optimization
  - [ ] Ensure .dockerignore is configured to exclude node_modules, .next, etc.

- [ ] Task 3: Create Docker Compose Configuration (AC: 3, 7)
  - [ ] Create `docker-compose.yml` at project root
  - [ ] Define PostgreSQL service with postgres:16 image
  - [ ] Configure PostgreSQL environment variables (user, password, database)
  - [ ] Define backend service with build context pointing to `./backend`
  - [ ] Configure backend service with intuitive name: `librilabs-translator-backend`
  - [ ] Set backend port mapping (8000:8000)
  - [ ] Configure backend environment variables (DATABASE_URL, OPENAI_API_KEY)
  - [ ] Set backend depends_on: postgres
  - [ ] Configure backend volumes for development (mount source code)
  - [ ] Define frontend service with build context pointing to `./frontend`
  - [ ] Configure frontend service with intuitive name: `librilabs-translator-frontend`
  - [ ] Set frontend port mapping (3000:3000)
  - [ ] Configure frontend environment variables (NEXT_PUBLIC_API_URL)
  - [ ] Set frontend depends_on: backend
  - [ ] Configure frontend volumes for development (mount source code, exclude node_modules and .next)
  - [ ] Define PostgreSQL volume for data persistence
  - [ ] Verify all services can start together

- [ ] Task 4: Create Makefile with Standard Commands (AC: 4, 5, 8)
  - [ ] Create `Makefile` at project root
  - [ ] Add `make build` command to build all Docker images
  - [ ] Add `make up` command to start all services in detached mode
  - [ ] Add `make up-dev` command to start services with volume mounting for hot-reload
  - [ ] Add `make down` command to stop and remove all containers
  - [ ] Add `make logs` command to view logs from all services
  - [ ] Add `make logs-backend` command to view backend logs only
  - [ ] Add `make logs-frontend` command to view frontend logs only
  - [ ] Add `make logs-db` command to view database logs only
  - [ ] Add `make clean` command to remove containers, volumes, and images
  - [ ] Add `make restart` command to restart all services
  - [ ] Add `make ps` command to show running containers
  - [ ] Ensure all commands use intuitive service names from docker-compose.yml
  - [ ] Document Makefile commands in README

- [ ] Task 5: Configure Environment Variables (AC: 7)
  - [ ] Create `.env.example` at project root with all required environment variables
  - [ ] Include DATABASE_URL for PostgreSQL connection
  - [ ] Include OPENAI_API_KEY placeholder
  - [ ] Include NEXT_PUBLIC_API_URL for frontend
  - [ ] Verify `.env` is in `.gitignore` (add if missing)
  - [ ] Document environment variable setup in README
  - [ ] Ensure docker-compose.yml uses environment variable substitution

- [ ] Task 6: Test Containerized Application (AC: 9, 10, 11)
  - [ ] Build all Docker images using `make build`
  - [ ] Start all services using `make up-dev`
  - [ ] Verify backend container starts successfully
  - [ ] Verify frontend container starts successfully
  - [ ] Verify PostgreSQL container starts successfully
  - [ ] Test backend health check endpoint from host: `curl http://localhost:8000/health`
  - [ ] Test backend health check endpoint from within backend container
  - [ ] Verify frontend is accessible at http://localhost:3000
  - [ ] Verify frontend can communicate with backend API
  - [ ] Test hot-reload functionality (modify code, verify changes reflect)
  - [ ] Verify database connection from backend container works
  - [ ] Test all services can be stopped with `make down`
  - [ ] Test clean command removes all containers and volumes

- [ ] Task 7: Document Development Workflow (AC: 12)
  - [ ] Update project README.md with Docker setup instructions
  - [ ] Document Makefile commands and their purposes
  - [ ] Include quick start guide using Makefile
  - [ ] Document environment variable setup process
  - [ ] Include troubleshooting section for common Docker issues
  - [ ] Document how to access services (URLs, ports)
  - [ ] Include notes about development vs production Docker configurations

## Dev Notes

### Previous Story Insights

From Story 1.1 (Set Up FastAPI Backend Structure with Health Check):
- FastAPI backend is fully set up with health check endpoint at `/health`
- Backend runs on port 8000
- Backend uses environment variables for configuration (OPENAI_API_KEY)
- Backend structure is ready for containerization
- Health check endpoint can be used to verify containerized backend is working

From Story 1.0 (Upgrade Frontend and Set Up Testing Infrastructure):
- Frontend is running Next.js 16.0.4 and React 19
- Frontend runs on port 3000
- Frontend structure is ready for containerization

### Docker Configuration Specifications

**Docker Compose Structure:**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: librilabs
      POSTGRES_PASSWORD: librilabs_dev
      POSTGRES_DB: librilabs_translator
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  librilabs-translator-backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://librilabs:librilabs_dev@postgres:5432/librilabs_translator
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      - postgres
    volumes:
      - ./backend:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  librilabs-translator-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:8000
    depends_on:
      - librilabs-translator-backend
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.next
    command: npm run dev

volumes:
  postgres_data:
```

[Source: architecture/unified-project-structure.md#docker-compose-for-local-development]

**Backend Dockerfile Pattern:**
- Base image: Python 3.14
- Working directory: /app
- Install dependencies from requirements.txt
- Copy application code
- Expose port 8000
- Command: `uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload` (for dev)

**Frontend Dockerfile Pattern:**
- Base image: Node.js (version compatible with Next.js 16.0.4)
- Working directory: /app
- Install dependencies from package.json
- Copy application code
- Expose port 3000
- Command: `npm run dev` (for dev)

**Makefile Standard Commands:**
- `make build` - Build all Docker images
- `make up` - Start all services (detached)
- `make up-dev` - Start all services with volume mounting for hot-reload
- `make down` - Stop and remove all containers
- `make logs` - View logs from all services
- `make logs-backend` - View backend logs
- `make logs-frontend` - View frontend logs
- `make logs-db` - View database logs
- `make clean` - Remove containers, volumes, and images
- `make restart` - Restart all services
- `make ps` - Show running containers

### File Locations

**New Files to Create:**
- `backend/Dockerfile` - Backend container definition
- `frontend/Dockerfile` - Frontend container definition
- `docker-compose.yml` - Docker Compose configuration (project root)
- `Makefile` - Development workflow commands (project root)
- `.env.example` - Environment variable template (project root)
- `backend/.dockerignore` - Docker ignore patterns for backend
- `frontend/.dockerignore` - Docker ignore patterns for frontend

**Files to Modify:**
- `README.md` - Add Docker setup and Makefile documentation
- `.gitignore` - Ensure `.env` is ignored

### Technical Constraints

**Technology Versions:**
- Python: 3.14 (backend)
- Node.js: Version compatible with Next.js 16.0.4 (frontend)
- PostgreSQL: 16 (database)
- Docker Compose: 3.8 format

**Docker Requirements:**
- Docker images must use intuitive names: `librilabs-translator-backend`, `librilabs-translator-frontend`
- Volume mounting must be configured for development mode (hot-reload)
- Environment variables must be properly configured via .env files
- Services must start in correct order (postgres → backend → frontend)

**Makefile Requirements:**
- All commands must be intuitive and follow standard naming conventions
- Commands must use service names from docker-compose.yml
- Development mode must support hot-reload via volume mounting
- Clean command must remove all containers, volumes, and images

### Testing Requirements

**Testing Standards:**
- Verify all Docker images can be built successfully
- Verify all services can start together
- Verify backend health check endpoint works from containerized backend
- Verify frontend can communicate with backend API
- Verify hot-reload works for both frontend and backend
- Verify database connection works from backend container
- Verify all Makefile commands work correctly
- Verify clean command removes all resources

**Test Execution:**
- Build images: `make build`
- Start services: `make up-dev`
- Test health check: `curl http://localhost:8000/health`
- Test frontend: Open http://localhost:3000 in browser
- Test database: Verify backend can connect to PostgreSQL
- Stop services: `make down`
- Clean up: `make clean`

### Project Structure Notes

**Alignment with Architecture:**
- Docker Compose configuration matches architecture specification
- Service names use intuitive naming convention
- Volume mounting supports development workflow
- Environment variables follow established patterns from Story 1.1

**No structural conflicts identified** - Docker setup aligns with unified project structure and deployment architecture.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Story created (moved from Story 1.7 to Story 1.2) | John (PM) |

## Dev Agent Record

This section is populated by the development agent during implementation.

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_Results from QA Agent review of the completed story implementation_

