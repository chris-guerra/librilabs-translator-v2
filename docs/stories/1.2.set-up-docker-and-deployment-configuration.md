# Story 1.2: Set Up Docker and Deployment Configuration

## Status
Done

## Story

**As a** developer,  
**I want** Docker containerization for both frontend and backend with a Makefile for easy development workflow,  
**so that** I can deploy the application consistently across environments and develop with containerized services.

## Acceptance Criteria

1. Dockerfile is created for FastAPI backend with latest stable Python version
2. Dockerfile is created for Next.js frontend (or multi-stage build)
3. docker-compose.yml is created for local development (backend, frontend, PostgreSQL)
4. Makefile is created with standard development commands (build, up, down, logs, clean, etc.)
5. Makefile supports volume mounting for development mode (hot-reload for both frontend and backend)
6. Docker images use intuitive names (e.g., `librilabs-translator-backend`, `librilabs-translator-frontend`)
7. Environment variables are properly configured via .env files
8. Docker containers can be built and run locally using Makefile commands
9. Application runs successfully in Docker containers
10. Backend health check endpoint works from containerized backend
11. Frontend can communicate with backend API from containers
12. Development workflow is documented (using Makefile commands)

## Tasks / Subtasks

- [x] Task 1: Create Backend Dockerfile (AC: 1)
  - [x] Create `backend/Dockerfile` with latest stable Python version base image
  - [x] Install system dependencies if needed
  - [x] Create non-root user for running the application (security best practice)
  - [x] Copy requirements.txt and install Python dependencies
  - [x] Copy application code
  - [x] Set working directory
  - [x] Switch to non-root user before running application
  - [x] Expose port 8000
  - [x] Set default command to run uvicorn
  - [x] Use multi-stage build if appropriate for optimization
  - [x] Ensure .dockerignore is configured to exclude unnecessary files
  - [x] Validate that secrets are not exposed in Docker image layers (use build-time secrets or environment variables, not COPY commands for sensitive files)

- [x] Task 2: Create Frontend Dockerfile (AC: 2)
  - [x] Create `frontend/Dockerfile` with Node.js base image (appropriate version for Next.js 16.0.4)
  - [x] Install dependencies
  - [x] Create non-root user for running the application (security best practice)
  - [x] Copy application code
  - [x] Set working directory
  - [x] Switch to non-root user before running application
  - [x] Expose port 3000
  - [x] Set default command for development mode
  - [x] Consider multi-stage build for production optimization
  - [x] Ensure .dockerignore is configured to exclude node_modules, .next, etc.
  - [x] Validate that secrets are not exposed in Docker image layers (use build-time secrets or environment variables, not COPY commands for sensitive files)

- [x] Task 3: Create Docker Compose Configuration (AC: 3, 7)
  - [x] Create `docker-compose.yml` at project root
  - [x] Define PostgreSQL service with postgres:16 image
  - [x] Configure PostgreSQL environment variables (user, password, database)
  - [x] Define backend service with build context pointing to `./backend`
  - [x] Configure backend service with intuitive name: `librilabs-translator-backend`
  - [x] Set backend port mapping (8000:8000)
  - [x] Configure backend environment variables (DATABASE_URL, OPENAI_API_KEY)
  - [x] Set backend depends_on: postgres
  - [x] Configure backend volumes for development (mount source code)
  - [x] Define frontend service with build context pointing to `./frontend`
  - [x] Configure frontend service with intuitive name: `librilabs-translator-frontend`
  - [x] Set frontend port mapping (3000:3000)
  - [x] Configure frontend environment variables (NEXT_PUBLIC_API_URL)
  - [x] Set frontend depends_on: backend
  - [x] Configure frontend volumes for development (mount source code, exclude node_modules and .next)
  - [x] Define PostgreSQL volume for data persistence
  - [x] Verify all services can start together

- [x] Task 4: Create Makefile with Standard Commands (AC: 4, 5, 8)
  - [x] Create `Makefile` at project root
  - [x] Add `make build` command to build all Docker images
  - [x] Add `make up` command to start all services in detached mode
  - [x] Add `make up-dev` command to start services with volume mounting for hot-reload
  - [x] Add `make down` command to stop and remove all containers
  - [x] Add `make logs` command to view logs from all services
  - [x] Add `make logs-backend` command to view backend logs only
  - [x] Add `make logs-frontend` command to view frontend logs only
  - [x] Add `make logs-db` command to view database logs only
  - [x] Add `make clean` command to remove containers, volumes, and images
  - [x] Add `make restart` command to restart all services
  - [x] Add `make ps` command to show running containers
  - [x] Ensure all commands use intuitive service names from docker-compose.yml
  - [x] Document Makefile commands in README

- [x] Task 5: Configure Environment Variables (AC: 7)
  - [x] Create `backend/.env.example` with backend-specific environment variables
  - [x] Create `frontend/.env.example` with frontend-specific environment variables
  - [x] Include OPENAI_API_KEY placeholder in backend/.env.example
  - [x] Include NEXT_PUBLIC_API_URL placeholder in frontend/.env.example
  - [x] Verify `.env` files are in `.gitignore` (already configured in frontend/.gitignore)
  - [x] Document environment variable setup in README
  - [x] Ensure docker-compose.yml uses environment variable substitution and env_file for each service

- [x] Task 6: Test Containerized Application (AC: 9, 10, 11)
  - [x] Build all Docker images using `make build`
  - [x] Perform Docker image security scanning (use `docker scout` or similar tool to identify vulnerabilities)
  - [x] Start all services using `make up-dev`
  - [x] Verify backend container starts successfully
  - [x] Verify frontend container starts successfully
  - [x] Verify PostgreSQL container starts successfully
  - [x] Test backend health check endpoint from host: `curl http://localhost:8000/health`
  - [x] Test backend health check endpoint from within backend container
  - [x] Verify frontend is accessible at http://localhost:3000
  - [x] Verify frontend can communicate with backend API
  - [x] Test hot-reload functionality (modify code, verify changes reflect)
  - [x] Verify database connection from backend container works
  - [x] Test container restart/recovery scenarios (stop container, restart, verify application recovers gracefully)
  - [x] Test container restart with `make restart` command
  - [x] Verify containers recover from unexpected termination (kill container process, restart, verify state)
  - [x] Test all services can be stopped with `make down`
  - [x] Test clean command removes all containers and volumes

- [x] Task 7: Document Development Workflow (AC: 12)
  - [x] Update project README.md with Docker setup instructions
  - [x] Document Makefile commands and their purposes
  - [x] Include quick start guide using Makefile
  - [x] Document environment variable setup process
  - [x] Include troubleshooting section for common Docker issues
  - [x] Document how to access services (URLs, ports)
  - [x] Include notes about development vs production Docker configurations

## Dev Notes

### Previous Story Insights

From Story 1.1 (Set Up FastAPI Backend Structure with Health Check):
- FastAPI backend is fully set up with health check endpoint at `/health`
- Backend runs on port 8000
- Backend uses environment variables for configuration (OPENAI_API_KEY)
- Backend structure is ready for containerization
- Health check endpoint can be used to verify containerized backend is working

From Story 1.0 (Upgrade Frontend and Set Up Testing Infrastructure):
- Frontend is running Next.js 16.0.4 and React 19
- Frontend runs on port 3000
- Frontend structure is ready for containerization

### Docker Configuration Specifications

**Docker Compose Structure:**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: librilabs
      POSTGRES_PASSWORD: librilabs_dev
      POSTGRES_DB: librilabs_translator
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  librilabs-translator-backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://librilabs:librilabs_dev@postgres:5432/librilabs_translator
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      - postgres
    volumes:
      - ./backend:/app
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

  librilabs-translator-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:8000
    depends_on:
      - librilabs-translator-backend
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.next
    command: npm run dev

volumes:
  postgres_data:
```

[Source: architecture/unified-project-structure.md#docker-compose-for-local-development]

**Backend Dockerfile Pattern:**
- Base image: Latest stable Python version
- Working directory: /app
- Create and use non-root user (security best practice)
- Install dependencies from requirements.txt
- Copy application code
- Expose port 8000
- Command: `uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload` (for dev)
- Ensure secrets are not exposed in image layers (use environment variables or build secrets)

**Frontend Dockerfile Pattern:**
- Base image: Node.js (version compatible with Next.js 16.0.4)
- Working directory: /app
- Create and use non-root user (security best practice)
- Install dependencies from package.json
- Copy application code
- Expose port 3000
- Command: `npm run dev` (for dev)
- Ensure secrets are not exposed in image layers (use environment variables or build secrets)

**Makefile Standard Commands:**
- `make build` - Build all Docker images
- `make up` - Start all services (detached)
- `make up-dev` - Start all services with volume mounting for hot-reload
- `make down` - Stop and remove all containers
- `make logs` - View logs from all services
- `make logs-backend` - View backend logs
- `make logs-frontend` - View frontend logs
- `make logs-db` - View database logs
- `make clean` - Remove containers, volumes, and images
- `make restart` - Restart all services
- `make ps` - Show running containers

### File Locations

**New Files to Create:**
- `backend/Dockerfile` - Backend container definition
- `backend/docker-compose.yml` - Backend Docker Compose configuration (for independent development)
- `backend/Makefile` - Backend-specific development workflow commands
- `backend/.dockerignore` - Docker ignore patterns for backend
- `backend/.env.example` - Backend environment variable template
- `frontend/Dockerfile` - Frontend container definition
- `frontend/docker-compose.yml` - Frontend Docker Compose configuration (for independent development)
- `frontend/Makefile` - Frontend-specific development workflow commands
- `frontend/.dockerignore` - Docker ignore patterns for frontend
- `frontend/.env.example` - Frontend environment variable template
- `frontend/docker-entrypoint.sh` - Entrypoint script for frontend permission handling
- `docker-compose.yml` - Full-stack Docker Compose configuration (project root, orchestrates all services)
- `Makefile` - Full-stack development workflow commands (project root, with delegation to project Makefiles)

**Files to Modify:**
- `README.md` - Add Docker setup and Makefile documentation
- `.gitignore` - Ensure `.env` is ignored

### Technical Constraints

**Technology Versions:**
- Python: Latest stable version (backend) - will be used in Docker containers
- Node.js: Version compatible with Next.js 16.0.4 (frontend)
- PostgreSQL: 16 (database)
- Docker Compose: 3.8 format

**Docker Requirements:**
- Docker images must use intuitive names: `librilabs-translator-backend`, `librilabs-translator-frontend`
- Volume mounting must be configured for development mode (hot-reload)
- Environment variables must be properly configured via .env files
- Services must start in correct order (postgres → backend → frontend)

**Makefile Requirements:**
- All commands must be intuitive and follow standard naming conventions
- Commands must use service names from docker-compose.yml
- Development mode must support hot-reload via volume mounting
- Clean command must remove all containers, volumes, and images

### Testing Requirements

**Testing Standards:**
- Verify all Docker images can be built successfully
- Perform Docker image security scanning to identify vulnerabilities
- Verify all services can start together
- Verify backend health check endpoint works from containerized backend
- Verify frontend can communicate with backend API
- Verify hot-reload works for both frontend and backend
- Verify database connection works from backend container
- Verify all Makefile commands work correctly
- Verify clean command removes all resources
- Test container restart and recovery scenarios
- Verify containers recover gracefully from unexpected termination
- Validate that secrets are not exposed in Docker image layers

**Test Execution:**
- Build images: `make build`
- Scan images for security vulnerabilities: `docker scout cves <image-name>` or similar
- Start services: `make up-dev`
- Test health check: `curl http://localhost:8000/health`
- Test frontend: Open http://localhost:3000 in browser
- Test database: Verify backend can connect to PostgreSQL
- Test container restart: `make restart` and verify services recover
- Test container recovery: Kill container process, restart, verify state preservation
- Stop services: `make down`
- Clean up: `make clean`

**Edge Case Testing:**
- Test with missing environment variables (verify graceful error handling)
- Test container restart scenarios (stop/start, verify application state)
- Test Docker image cleanup and rebuild (verify no cached secrets)
- Test with different environment variable configurations
- Test container resource limits (if applicable)
- Test network connectivity between containers after restart
- Test volume persistence after container restart
- Test application behavior when database container is temporarily unavailable

### Project Structure Notes

**Alignment with Architecture:**
- Docker Compose configuration matches architecture specification
- Service names use intuitive naming convention
- Volume mounting supports development workflow
- Environment variables follow established patterns from Story 1.1

**No structural conflicts identified** - Docker setup aligns with unified project structure and deployment architecture.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Story created (moved from Story 1.7 to Story 1.2) | John (PM) |

## Dev Agent Record

This section is populated by the development agent during implementation.

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Debug Log References
- Docker build process completed successfully for both backend and frontend
- Frontend permission issue resolved with entrypoint script for .next directory
- All services verified running and healthy
- Security scanning completed (vulnerabilities identified but expected for base images)

### Completion Notes List
- Backend Dockerfile: Multi-stage build with Python 3.13-slim, non-root user (appuser), curl installed for healthchecks
- Frontend Dockerfile: Multi-stage build with Node.js 20-slim, development and production stages, entrypoint script for permission handling
- Docker Compose: All services configured with healthchecks, proper dependencies, volume mounts for hot-reload, restart policies (unless-stopped) for production readiness
- Makefile: All standard commands implemented using docker compose (v2)
- Environment Variables: Separate .env.example files created in backend/ and frontend/ folders to maintain project independence
- Independent Project Structure: Each project (backend/ and frontend/) has its own docker-compose.yml and Makefile, allowing 100% independent development and future project splitting
- Testing: All services verified working, health checks passing, frontend accessible, restart/recovery tested
- Documentation: Comprehensive Docker setup guide added to README.md with troubleshooting section and production deployment strategy
- QA Fixes Applied:
  - ✅ Added restart policies (`restart: unless-stopped`) to all docker-compose.yml files (root, backend, frontend)
  - ✅ Verified pre-commit hooks for secret detection (already configured in backend/.pre-commit-config.yaml)
  - ✅ Added production deployment strategy documentation to README.md (Railway deployment, production considerations, security, monitoring, scaling)

### File List
**New Files Created:**
- `backend/Dockerfile` - Backend container definition with multi-stage build
- `backend/.dockerignore` - Docker ignore patterns for backend
- `backend/.env.example` - Backend environment variable template
- `backend/docker-compose.yml` - Backend Docker Compose configuration (backend + PostgreSQL for independent development)
- `backend/Makefile` - Backend-specific development workflow commands
- `frontend/Dockerfile` - Frontend container definition with multi-stage build (development and production stages)
- `frontend/.dockerignore` - Docker ignore patterns for frontend
- `frontend/.env.example` - Frontend environment variable template
- `frontend/docker-compose.yml` - Frontend Docker Compose configuration (for independent development)
- `frontend/Makefile` - Frontend-specific development workflow commands
- `frontend/docker-entrypoint.sh` - Entrypoint script for frontend permission handling
- `docker-compose.yml` - Full-stack Docker Compose configuration (orchestrates all services)
- `Makefile` - Full-stack development workflow commands (with delegation to project Makefiles)

**Files Modified:**
- `README.md` - Added comprehensive Docker setup, development workflow documentation, and production deployment strategy
- `docker-compose.yml` - Added restart policies (`restart: unless-stopped`) for production readiness
- `backend/docker-compose.yml` - Added restart policies (`restart: unless-stopped`) for production readiness
- `frontend/docker-compose.yml` - Added restart policies (`restart: unless-stopped`) for production readiness
- `docker-compose.yml` - Added restart policies for production readiness
- `backend/docker-compose.yml` - Added restart policies for production readiness
- `frontend/docker-compose.yml` - Added restart policies for production readiness

## QA Results

### Review Date: 2025-01-27

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment**: Excellent implementation with comprehensive security practices, well-structured Docker configuration, and thorough documentation. All 12 acceptance criteria are fully met with evidence of proper implementation and testing.

**Implementation Highlights**:
- ✅ Multi-stage Docker builds for both backend and frontend (optimized image sizes)
- ✅ Non-root users implemented in all containers (security best practice)
- ✅ Environment variable substitution used throughout (no hardcoded secrets)
- ✅ Health checks with service dependencies prevent startup race conditions
- ✅ Comprehensive documentation in README with troubleshooting guide
- ✅ Independent project structure allows future splitting
- ✅ All Makefile commands implemented and documented

**Code Quality**: High
- Dockerfiles follow best practices (multi-stage builds, non-root users, proper layer caching)
- Docker Compose configuration well-structured with health checks and proper dependencies
- Makefile commands are intuitive and follow standard conventions
- Configuration files are well-commented and maintainable

### Refactoring Performed

*No refactoring performed during review - implementation is already well-structured.*

### Compliance Check

- **Coding Standards**: ✓ Compliant - Docker configuration follows best practices
- **Project Structure**: ✓ Compliant - Aligns with unified project structure, supports independent development
- **Testing Strategy**: ✓ Compliant - Comprehensive test design created (79 test scenarios), manual testing verified all ACs
- **All ACs Met**: ✓ All 12 acceptance criteria fully implemented and verified

### Improvements Checklist

- [x] All acceptance criteria verified and met
- [x] Security best practices implemented (non-root users, secret management)
- [x] Health checks and service dependencies configured
- [x] Documentation comprehensive and developer-friendly
- [x] Makefile commands all implemented and working
- [x] Environment variables properly configured
- [x] Restart policies added for production (`restart: unless-stopped` in all docker-compose.yml files)
- [x] Pre-commit hooks for secret detection verified (already configured in backend/.pre-commit-config.yaml)
- [x] Production deployment strategy documented in README.md

### Security Review

**Status**: PASS - All security best practices implemented

**Findings**:
- ✅ Non-root users (`appuser`) implemented in both backend and frontend Dockerfiles
- ✅ No secrets copied into Docker image layers (multi-stage builds, .dockerignore configured)
- ✅ Environment variables used for all sensitive data (OPENAI_API_KEY, database credentials)
- ✅ Database credentials use environment variable substitution (with defaults acceptable for development)
- ✅ Security scanning performed as part of testing workflow
- ✅ `.env` files properly excluded from version control

**Security Measures Verified**:
- Backend Dockerfile: Non-root user, multi-stage build, no secret exposure
- Frontend Dockerfile: Non-root user, multi-stage build, entrypoint script for permissions
- Docker Compose: Environment variable substitution, health checks, proper dependencies
- .dockerignore files: Properly configured to exclude sensitive files

### Performance Considerations

**Status**: PASS - No performance concerns identified

**Findings**:
- ✅ Multi-stage builds reduce final image sizes
- ✅ .dockerignore files minimize build context
- ✅ Volume mounts optimized (exclude node_modules, .next, .venv)
- ✅ Efficient base images used (python:3.13-slim, node:20-slim)
- ✅ Layer caching optimized (dependencies before code copy)
- ✅ Hot-reload functionality verified and working

### Files Modified During Review

*No files modified during review - implementation is production-ready.*

### Gate Status

**Gate**: CONCERNS → `docs/qa/gates/1.2-set-up-docker-and-deployment-configuration.yml`

**Rationale**: Three high-risk areas (score 6) identified in risk assessment (SEC-004, SEC-001, TECH-002), but all are proactively mitigated through implementation. All NFRs pass. Gate marked CONCERNS per deterministic rule (risks ≥ 6 require monitoring), but implementation is production-ready for development environment.

**Risk Profile**: `docs/qa/assessments/1.2-risk-20250127.md`
- Total Risks: 18 (3 high, 7 medium, 8 low)
- Risk Score: 64/100
- All high risks mitigated through implementation

**Test Design**: `docs/qa/assessments/1.2-test-design-20250127.md`
- Total Test Scenarios: 79 (5 unit, 54 integration, 20 E2E)
- All 12 acceptance criteria have test coverage
- P0 tests: 27 (critical security and infrastructure tests)

**NFR Assessment**: `docs/qa/assessments/1.2-nfr-20250127.md`
- Security: PASS
- Performance: PASS
- Reliability: PASS
- Maintainability: PASS
- Quality Score: 100/100

### Recommended Status

✓ **Ready for Done**

All acceptance criteria are met, security best practices are implemented, comprehensive documentation is provided, and all identified risks are mitigated. The Docker setup is production-ready for development environment use. The CONCERNS gate status reflects the need for ongoing monitoring of the identified high-risk areas, but all risks are proactively addressed through implementation.

